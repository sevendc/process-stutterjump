<body onclick="!t>0&&I()"><p id=C>Click</p><canvas id=c></canvas><script>
c.width=w=innerWidth|0, c.height=h=innerHeight|0
document.body.style.cssText="cursor:none"
c.style.cssText="position:fixed;left:0;top:0;width:100%;height:100%"
C.style.cssText="font-size:12vw;"
for(x in (g=c.getContext("webgl")))g[x[(i=t=0)]+x[6]]=g[x]
with(g){p=cP(g.c=compileShader)
sS(s=cS(a=FN),`//*--
precision highp float;
#define rot(P,A,a) (mix(A*dot(P,A),P,cos(a))+sin(a)*cross(P,A))
#define V vec3
uniform float t;
V k,p,l=V(.01,0,0),q,s; // using q as a animation camera, r as animating fractal
float m,a,e,g,h,d; // m = time, a = phase., g = distance total, e = distance, h = ditance from 0, d = distance to start mirror
vec2 r = vec2(${w}.,${h}.); 

void main(){   	

    vec4 o;
    a = mod(t*.3, 9.);
    
    d=t<35.||t>46.5&&t<70.||t>81.5&&t<93.?max(sin(t*22.)*.2,0.):0.; // pomppu 
  
    q=V(2.11,-2.8,0.); // camera
    s=V(6.282+sin(a)*.2,.15,0.); // fractal

    // Overwrite with each case. The last true wins.
    if(a>0.){q=V(1.3,-6.5,.1*a-.5);s=V(7.1,.19,0.);}
    if(a>1.){q=V(2.2,-2.+a,0.);s=V(-.3,.2,.2);}
    if(a>2.){q=V(1.9+a*.1,a*.1,a*.1);s=V(7.17,.15,0.);}
    if(a>3.){q=V(3.2,-1.+a,.1);s=V(-1.1+a*.5,.2,.2);}
    if(a>4.){q=V(2.2,-2.+a,0.);s=V(0.2+sin(a),.2,.2);}
    if(a>5.){q=V(2.2,-2.,-1.+a);s=V(-.2,16.2,.5);}
    if(a>6.){q=V(2.2,-3.,6.);s=V(.1,.8,1.8-a*.1);}
    if(a>7.){q=V(3.2,-3.,6.);s=V(6.1,.8,2.8-a*.4);}
    if(a>8.){q=V(3.2,-6.,.1);s=V(6.1,.8,1.8);}
      
    for(float i=0.;i<79.;i++) {                 
        p=V((gl_FragCoord.xy+vec2(sin(gl_FragCoord.y*.1+t*90.)*35.*exp(-mod(t,3.)*4.),0.)-r.xy*.5)/r.y*g,g-q.x);
        p=k=rot(p,V(2. + .1* cos(a)+q.y+d, 3. + .1* sin(a)+q.z, 1),.27); // camera rotation                
                  
        if (t < 62.) {
          e = t > 31. ? (length(vec2((length(vec2(length(p.xy)-1.1-q.z*.1-d+sin(a*3.)*.7,
                length(p.zy)-1.5))-.5), dot(cos(p*12.),sin(p.zxy*12.+t+d))*.1))-.02)*.3 :
            length(sin(p)+cos(p*sin(t*a)*.1))-.5-s.y*.1;
        } else {
          for(float j=0.;j<7.;j++)            
            p=rot(p,V(s.z,2.* smoothstep(-3.,5.,s.y)-1.,1),s.x),            
            p=abs(p+p)-2.;                        
            e = (length(p.xz)-1.)/3e2;         
        }
        g+=e;

        o+=min(exp(-e*1e5)/7e1,.01);                            
    }    
    o.r += max((sin(g*5.+t))*.2, 0.0);
    o += d; 
    o.rgb *= clamp((min(t, 101. - t) / 3.), 0.0, 1.0); // fade in and out
    gl_FragColor = vec4(o.xyz,1.) * vec4(.61,.6,.62,1.);       
}//*--`)
c(s)

 // -- dev start
if (!g.getShaderParameter(s, g.COMPILE_STATUS)) {
    console.log(g.getShaderInfoLog(s));
    alert('shader compilation error: ' + g.getShaderInfoLog(s));
} 
 // -- dev end

aS(p,s)
sS(s=cS(++a),"attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}")
c(s)
aS(p,s)
lo(p)
ug(p)
eV(e=gr(p,"p"))
vA(e,2,5126,0,bf(d=34962,cB()),bD(d,new Float32Array([b=-1,b,b,3,3,b]),35044))
I=()=>{
t++;  
  // music stuff      
  // This music has been exported by SoundBox. You can use it with
    // http://sb.bitsnbites.eu/player-small.js in your own product.

    // See http://sb.bitsnbites.eu/demo.html for an example of how to
    // use it in a demo.

        // This music has been exported by SoundBox. You can use it with
    // http://sb.bitsnbites.eu/player-small.js in your own product.

    // See http://sb.bitsnbites.eu/demo.html for an example of how to
    // use it in a demo.
  
  // Song data
    var song = {
      songData: [
        { // Instrument 0
          i: [
          1, // OSC1_WAVEFORM
          255, // OSC1_VOL
          128, // OSC1_SEMI
          0, // OSC1_XENV
          2, // OSC2_WAVEFORM
          255, // OSC2_VOL
          128, // OSC2_SEMI
          1, // OSC2_DETUNE
          255, // OSC2_XENV
          29, // NOISE_VOL
          5, // ENV_ATTACK
          7, // ENV_SUSTAIN
          39, // ENV_RELEASE
          9, // ENV_EXP_DECAY
          0, // ARP_CHORD
          0, // ARP_SPEED
          0, // LFO_WAVEFORM
          167, // LFO_AMT
          2, // LFO_FREQ
          1, // LFO_FX_FREQ
          2, // FX_FILTER
          37, // FX_FREQ
          47, // FX_RESONANCE
          15, // FX_DIST
          109, // FX_DRIVE
          116, // FX_PAN_AMT
          4, // FX_PAN_FREQ
          91, // FX_DELAY_AMT
          1 // FX_DELAY_TIME
          ],
          // Patterns
          p: [1,1,1,1,1,1,1,1,1,1,1,1,,,,,1,1,1,1,1,1,1,1,,,,,1,1,1,1],
          // Columns
          c: [
            {n: [,108,108,108,,108,108,108,,108,108,108,,108,108,108,,108,108,108,,108,108,108,,108,108,108,,108,106,108],
             f: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,3,2,1,,3,2,1,,3,2,1,,3,2,1,,3,2,1,,3,2,1,,3,2,1,,3,2,1]}
          ]
        },
        { // Instrument 1
          i: [
          0, // OSC1_WAVEFORM
          255, // OSC1_VOL
          116, // OSC1_SEMI
          64, // OSC1_XENV
          0, // OSC2_WAVEFORM
          255, // OSC2_VOL
          110, // OSC2_SEMI
          0, // OSC2_DETUNE
          36, // OSC2_XENV
          0, // NOISE_VOL
          4, // ENV_ATTACK
          5, // ENV_SUSTAIN
          100, // ENV_RELEASE
          12, // ENV_EXP_DECAY
          0, // ARP_CHORD
          0, // ARP_SPEED
          0, // LFO_WAVEFORM
          0, // LFO_AMT
          0, // LFO_FREQ
          0, // LFO_FX_FREQ
          1, // FX_FILTER
          5, // FX_FREQ
          98, // FX_RESONANCE
          66, // FX_DIST
          212, // FX_DRIVE
          0, // FX_PAN_AMT
          0, // FX_PAN_FREQ
          0, // FX_DELAY_AMT
          0 // FX_DELAY_TIME
          ],
          // Patterns
          p: [1,1,1,,1,1,1,,1,1,1,1,2,,,,1,1,1,,1,1,1,,,,,,1,1,1,1],
          // Columns
          c: [
            {n: [135,,,,135,,,,135,,,,135,,,,135,,,,135,,,,135,,,,135],
             f: []},
            {n: [135],
             f: []}
          ]
        },
        { // Instrument 2
          i: [
          0, // OSC1_WAVEFORM
          234, // OSC1_VOL
          128, // OSC1_SEMI
          59, // OSC1_XENV
          0, // OSC2_WAVEFORM
          76, // OSC2_VOL
          128, // OSC2_SEMI
          13, // OSC2_DETUNE
          55, // OSC2_XENV
          206, // NOISE_VOL
          4, // ENV_ATTACK
          7, // ENV_SUSTAIN
          65, // ENV_RELEASE
          85, // ENV_EXP_DECAY
          0, // ARP_CHORD
          0, // ARP_SPEED
          0, // LFO_WAVEFORM
          21, // LFO_AMT
          8, // LFO_FREQ
          1, // LFO_FX_FREQ
          2, // FX_FILTER
          30, // FX_FREQ
          0, // FX_RESONANCE
          1, // FX_DIST
          72, // FX_DRIVE
          61, // FX_PAN_AMT
          5, // FX_PAN_FREQ
          0, // FX_DELAY_AMT
          1 // FX_DELAY_TIME
          ],
          // Patterns
          p: [,,,,,,,,1,1,1,1,,,,,1,1,1,1,1,1,1,1,,,,,1,1,1,1],
          // Columns
          c: [
            {n: [,,,,99,,,,,,,,99,,,,,,,,99,,,,,,,,99],
             f: []}
          ]
        },
        { // Instrument 3
          i: [
          0, // OSC1_WAVEFORM
          0, // OSC1_VOL
          140, // OSC1_SEMI
          0, // OSC1_XENV
          0, // OSC2_WAVEFORM
          0, // OSC2_VOL
          142, // OSC2_SEMI
          0, // OSC2_DETUNE
          0, // OSC2_XENV
          80, // NOISE_VOL
          4, // ENV_ATTACK
          10, // ENV_SUSTAIN
          47, // ENV_RELEASE
          55, // ENV_EXP_DECAY
          0, // ARP_CHORD
          0, // ARP_SPEED
          0, // LFO_WAVEFORM
          187, // LFO_AMT
          5, // LFO_FREQ
          0, // LFO_FX_FREQ
          1, // FX_FILTER
          255, // FX_FREQ
          97, // FX_RESONANCE
          2, // FX_DIST
          44, // FX_DRIVE
          53, // FX_PAN_AMT
          5, // FX_PAN_FREQ
          89, // FX_DELAY_AMT
          2 // FX_DELAY_TIME
          ],
          // Patterns
          p: [,,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,3,3,3,3,3,,1,2,1,1,1,1,3],
          // Columns
          c: [
            {n: [,,111,,,,111,,,,111,,,135,111,,,,111,,,,111,,,,111,,,135,111],
             f: []},
            {n: [,,111,,,,111,,,,111,,,135,111],
             f: []},
            {n: [135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135],
             f: [25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,23,8,27,4,44,8,27,4,23,8,27,4,44,8,27,4,23,8,27,4,44,8,27,4,23,8,27,4,44,8,27,4]}
          ]
        },
        { // Instrument 4
          i: [
          1, // OSC1_WAVEFORM
          191, // OSC1_VOL
          128, // OSC1_SEMI
          0, // OSC1_XENV
          1, // OSC2_WAVEFORM
          239, // OSC2_VOL
          128, // OSC2_SEMI
          0, // OSC2_DETUNE
          186, // OSC2_XENV
          0, // NOISE_VOL
          12, // ENV_ATTACK
          16, // ENV_SUSTAIN
          25, // ENV_RELEASE
          148, // ENV_EXP_DECAY
          12, // ARP_CHORD
          5, // ARP_SPEED
          0, // LFO_WAVEFORM
          97, // LFO_AMT
          2, // LFO_FREQ
          1, // LFO_FX_FREQ
          1, // FX_FILTER
          18, // FX_FREQ
          168, // FX_RESONANCE
          43, // FX_DIST
          32, // FX_DRIVE
          203, // FX_PAN_AMT
          6, // FX_PAN_FREQ
          61, // FX_DELAY_AMT
          6 // FX_DELAY_TIME
          ],
          // Patterns
          p: [,,,,,,,,1,1,1,1,,,1,1,1,1,1,1,1,1,1,1,1,1,,,1,,1,,1,1],
          // Columns
          c: [
            {n: [132,132,144,132,144,144,145,144,132,132,144,132,144,144,145,144,132,132,144,132,144,144,145,144,132,132,144,132,144,144,145,144],
             f: []}
          ]
        },
        { // Instrument 5
          i: [
          0, // OSC1_WAVEFORM
          0, // OSC1_VOL
          128, // OSC1_SEMI
          0, // OSC1_XENV
          0, // OSC2_WAVEFORM
          0, // OSC2_VOL
          128, // OSC2_SEMI
          0, // OSC2_DETUNE
          0, // OSC2_XENV
          125, // NOISE_VOL
          0, // ENV_ATTACK
          1, // ENV_SUSTAIN
          59, // ENV_RELEASE
          0, // ENV_EXP_DECAY
          0, // ARP_CHORD
          0, // ARP_SPEED
          0, // LFO_WAVEFORM
          0, // LFO_AMT
          0, // LFO_FREQ
          0, // LFO_FX_FREQ
          1, // FX_FILTER
          193, // FX_FREQ
          171, // FX_RESONANCE
          0, // FX_DIST
          29, // FX_DRIVE
          39, // FX_PAN_AMT
          3, // FX_PAN_FREQ
          88, // FX_DELAY_AMT
          3 // FX_DELAY_TIME
          ],
          // Patterns
          p: [,,,,1,1,1,1,1,1,1,1,,,,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          // Columns
          c: [
            {n: [,,123,,,,123,,,,123,,,,123,,,,123,,,,123,,,,123,,,,123],
             f: []}
          ]
        },
        { // Instrument 6
          i: [
          2, // OSC1_WAVEFORM
          100, // OSC1_VOL
          128, // OSC1_SEMI
          0, // OSC1_XENV
          3, // OSC2_WAVEFORM
          201, // OSC2_VOL
          128, // OSC2_SEMI
          20, // OSC2_DETUNE
          0, // OSC2_XENV
          29, // NOISE_VOL
          0, // ENV_ATTACK
          6, // ENV_SUSTAIN
          29, // ENV_RELEASE
          0, // ENV_EXP_DECAY
          0, // ARP_CHORD
          0, // ARP_SPEED
          0, // LFO_WAVEFORM
          195, // LFO_AMT
          4, // LFO_FREQ
          1, // LFO_FX_FREQ
          3, // FX_FILTER
          50, // FX_FREQ
          184, // FX_RESONANCE
          119, // FX_DIST
          160, // FX_DRIVE
          147, // FX_PAN_AMT
          6, // FX_PAN_FREQ
          44, // FX_DELAY_AMT
          6 // FX_DELAY_TIME
          ],
          // Patterns
          p: [,,,,,,,,,,,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2],
          // Columns
          c: [
            {n: [132,132,132,,132,132,132,,132,132,132,,132,132,132,,132,132,132,,132,132,132,,132,132,132,,132,130,132,132,135,135,135,,135,135,135,,135,135,135,,135,135,135,,135,135,135,,135,135,135,,135,135,135,,135,133,135,135],
             f: [1,,,,,,,,1,,,,,,,,1,,,,,,,,1,,,,,,,,3,,,,,,,,2,,,,,,,,1,,,,,,,,2]},
            {n: [132,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,135],
             f: []}
          ]
        },
        { // Instrument 7
          i: [
          2, // OSC1_WAVEFORM
          0, // OSC1_VOL
          128, // OSC1_SEMI
          0, // OSC1_XENV
          3, // OSC2_WAVEFORM
          0, // OSC2_VOL
          128, // OSC2_SEMI
          0, // OSC2_DETUNE
          0, // OSC2_XENV
          136, // NOISE_VOL
          5, // ENV_ATTACK
          255, // ENV_SUSTAIN
          58, // ENV_RELEASE
          0, // ENV_EXP_DECAY
          0, // ARP_CHORD
          0, // ARP_SPEED
          2, // LFO_WAVEFORM
          255, // LFO_AMT
          2, // LFO_FREQ
          1, // LFO_FX_FREQ
          2, // FX_FILTER
          60, // FX_FREQ
          0, // FX_RESONANCE
          0, // FX_DIST
          15, // FX_DRIVE
          147, // FX_PAN_AMT
          6, // FX_PAN_FREQ
          121, // FX_DELAY_AMT
          6 // FX_DELAY_TIME
          ],
          // Patterns
          p: [,,1,,,,1,,,,1,,,,1,,,,1,,,,1,,,,,,,,1],
          // Columns
          c: [
            {n: [135],
             f: []}
          ]
        },
      ],
      rowLen: 4009,   // In sample lengths
      patternLen: 32,  // Rows per pattern
      endPattern: 34,  // End pattern
      numChannels: 8  // Number of channels
    };

  /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
*
* Copyright (c) 2011-2013 Marcus Geelnard
*
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
*    claim that you wrote the original software. If you use this software
*    in a product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source
*    distribution.
*
*/

// Some general notes and recommendations:
//  * This code uses modern ECMAScript features, such as ** instead of
//    Math.pow(). You may have to modify the code to make it work on older
//    browsers.
//  * If you're not using all the functionality (e.g. not all oscillator types,
//    or certain effects), you can reduce the size of the player routine even
//    further by deleting the code.

// NOTE: seven_dc totally golfed this!  


    // Oscillators
     var ms = (v) => Math.sin(v * 6.283184)   // osc_sin         

     var mf = (n) => 0.003959503758 * (2 ** ((n - 128) / 12)) // getnotefreq

    var createNote = function (instr, n, rowLen) {
        
        var attack = instr.i[10] * instr.i[10] * 4,
            sustain = instr.i[11] * instr.i[11] * 4,
            release = instr.i[12] * instr.i[12] * 4,
            size = attack + sustain + release,        
            arp = instr.i[14];            

        var noteBuf = new Int32Array(size);

        // Re-trig oscillators
        var c1 = c2 = 0;

        // Local variables.
        var j, j2, e, t, rsample, o1t, o2t;

        // Generate one note (attack + sustain + release)
        for (j = 0, j2 = 0; j < size; j++, j2++) {
            if (j2 >= 0) {
                // Switch arpeggio note.
                arp = (arp >> 8) | ((arp & 255) << 4);
                j2 -= rowLen * (2 **(2 - instr.i[15]));

                // Calculate note frequencies for the oscillators
                o1t = mf(n + (arp & 15) + instr.i[2] - 128);
                o2t = mf(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
            }

            // Envelope
            e = 1;
            if (j < attack) {
                e = j / attack;
            } else if (j >= attack + sustain) {
                e = (j - attack - sustain) * 1 / release;
                e = (1 - e) * (3 ** (-instr.i[13]/16 * e));
            }

            // Oscillator 1
            c1 += o1t * e ** (instr.i[3]/32);
            rsample = mOscillators[instr.i[0]](c1) * instr.i[1];

            // Oscillator 2
            c2 += o2t * e ** (instr.i[8]/32);
            rsample += mOscillators[instr.i[4]](c2) * instr.i[5];

            // Noise oscillator
            if (instr.i[9]) {
                rsample += (2 * Math.random() - 1) * instr.i[9];
            }

            // Add to (mono) channel buffer
            noteBuf[j] = (80 * rsample * e) | 0;
        }

        return noteBuf;
    };


    //--------------------------------------------------------------------------
    // Private members
    //--------------------------------------------------------------------------

    // Array of oscillator functions
    var mOscillators = [
        ms,
        (v) => (v % 1) < 0.5 ? 1 : -1,
        (v) => 2 * (v % 1) - 1,
        (v) => {
          v2 = (v % 1) * 4;
          if(v2 < 2) return v2 - 1;
          return 3 - v2;
      }
    ];  

    // Private variables set up by init()
    var  mCurrentCol = 0, mNumWords = song.rowLen * song.patternLen * (song.endPattern + 1) * 2, mMixBuf = new Int32Array(mNumWords);  


    //--------------------------------------------------------------------------
    // Public methods
    //--------------------------------------------------------------------------

    // Generate audio data for a single track
    var generate = function () {      
        // Local variables
        var i, j, b, p, row, col, n, cp,
            k, t, lfor, e, x, rsample, rowStartSample, f, da;

        // Put performance critical items in local variables
        var chnBuf = new Int32Array(mNumWords),
            instr = song.songData[mCurrentCol],
            rowLen = song.rowLen,
            patternLen = song.patternLen;

        // Clear effect state
        var low = 0, band = 0, high;
        var lsample, filterActive = false;

        // Clear note cache.
        var noteCache = [];

         // Patterns
         for (p = 0; p <= song.endPattern; ++p) {
            cp = instr.p[p];

            // Pattern rows
            for (row = 0; row < patternLen; ++row) {
                // Execute effect command.
                x=instr.c[cp - 1]
                var cmdNo = cp && x.f ? x.f[row] : 0;
                if (cmdNo) {
                    instr.i[cmdNo - 1] = x.f[row + patternLen] || 0;

                    // Clear the note cache since the instrument has changed.
                    if (cmdNo < 17) {
                        noteCache = [];
                    }
                }

                // Put performance critical instrument properties in local variables
                var oscLFO = mOscillators[instr.i[16]],
                    lfoAmt = instr.i[17] / 512,
                    lfoFreq = (2 ** (instr.i[18] - 9)) / rowLen,
                    fxLFO = instr.i[19],
                    fxFilter = instr.i[20],
                    fxFreq = instr.i[21] * 43.23529 * 3.141592 / 44100,
                    q = 1 - instr.i[22] / 255,
                    dist = instr.i[23] * 1e-5,
                    drive = instr.i[24] / 32,
                    panAmt = instr.i[25] / 512,
                    panFreq = 6.283184 * (2 ** (instr.i[26] - 9)) / rowLen,
                    dlyAmt = instr.i[27] / 255,
                    dly = instr.i[28] * rowLen & ~1;  // Must be an even number

                // Calculate start sample number for this row in the pattern
                rowStartSample = (p * patternLen + row) * rowLen;

                // Generate notes for this pattern row
                for (col = 0; col < 4; ++col) {
                    n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                    if (n) {
                        if (!noteCache[n]) {
                            noteCache[n] = createNote(instr, n, rowLen);
                        }

                        // Copy note from the note cache
                        var noteBuf = noteCache[n];
                        for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                          chnBuf[i] += noteBuf[j];
                        }
                    }
                }

                // Perform effects for this pattern row
                for (j = 0; j < rowLen; j++) {
                    // Dry mono-sample
                    k = (rowStartSample + j) * 2;
                    rsample = chnBuf[k];

                    // We only do effects if we have some sound input
                    if (rsample || filterActive) {
                        // State variable filter
                        f = fxFreq;
                        if (fxLFO) {
                            f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                        }
                        f = 1.5 * Math.sin(f);
                        low += f * band;
                        high = q * (rsample - band) - low;
                        band += f * high;
                        rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                        // Distortion
                        if (dist) {
                            rsample *= dist;
                            rsample = rsample < 1 ? rsample > -1 ? ms(rsample*.25) : -1 : 1;
                            rsample /= dist;
                        }

                        // Drive
                        rsample *= drive;

                        // Is the filter active (i.e. still audiable)?
                        filterActive = rsample * rsample > 1e-5;

                        // Panning
                        t = Math.sin(panFreq * k) * panAmt + 0.5;
                        lsample = rsample * (1 - t);
                        rsample *= t;
                    } else {
                        lsample = 0;
                    }

                    // Delay is always done, since it does not need sound input
                    if (k >= dly) {
                        // Left channel = left + right[-p] * t
                        lsample += chnBuf[k-dly+1] * dlyAmt;

                        // Right channel = right + left[-p] * t
                        rsample += chnBuf[k-dly] * dlyAmt;
                    }

                    // Store in stereo channel buffer (needed for the delay effect)
                    chnBuf[k] = lsample | 0;
                    chnBuf[k+1] = rsample | 0;

                    // ...and add to stereo mix buffer
                    mMixBuf[k] += lsample | 0;
                    mMixBuf[k+1] += rsample | 0;
                }
            }
        }

        // Next iteration. Return progress (1.0 == done!).
        mCurrentCol++;
        return mCurrentCol / song.numChannels;
    };
    
    // Create a WAVE formatted Uint8Array from the generated audio data
    var createWave = () => {
        // Create WAVE header
        var headerLen = 44;
        var l1 = headerLen + mNumWords * 2 - 8;
        var l2 = l1 - 36;
        var wave = new Uint8Array(headerLen + mNumWords * 2);
        wave.set(
            [82,73,70,70,
             l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
             87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
             68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
             l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
        );

        // Append actual wave data
        for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
            // Note: We clamp here
            var y = mMixBuf[i];
            y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
            //y = y > (x=32767) ? x : (y < -x ? -x : y);
            wave[idx++] = y & 255;
            wave[idx++] = (y >> 8) & 255;
        }

        // Return the WAVE formatted typed array
        return wave;
    };   
    

c =()=>{
  C.innerHTML=b=generate()
  if (b === 1.) {   
        C.innerHTML="" 
        // Create an Audio element
        B = document.createElement("audio")
        B.src = URL.createObjectURL(new Blob([createWave()], { type: "audio/wav" }))
        B.play()
        
        // append B to body
        // This for seeking the demo. remove in final build like the debug
        // -- dev start
        B.controls = true;
        B.style.cssText="width:100%;position:fixed;bottom:0px"
        document.body.appendChild(B);        
        // -- dev end
        speechSynthesis.speak(new SpeechSynthesisUtterance("This is Proces Stutterjump"))      
        
  F() 
} else requestAnimationFrame(c)
}
c();
}
F=()=>{uniform1f(gf(p,"t"),t=B.currentTime),dr(4,0,3),requestAnimationFrame(F)} 
}       
</script>
